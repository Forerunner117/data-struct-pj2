                                     GRADER

Name of student running submit: Austin Longo
Login of student running submit: aulo9481

Second team member's name (if any):Chris Costello
Second team member's login:chco1865

Third team member's name (if any):Ian McLaughlin
Third team member's login:iamc6160

IMPORTANT:  Only one team member should submit their project to the moodle.
If a different teammate must submit, inform me (John Black) via email 
all the details.  Include a complete list of team members, and let me know
which submission you want graded.

If you've submitted your project once, or even written a substantial amount of
code together, you may not change partners without the permission of the
instructor.
===============================================================================
Does your program compile without errors?
  Yes.


Have you tested your program on the machines in the CSEL or VM?
  Yes.

Did you successfully implement game tree search?  Did you successfully
implement alpha-beta pruning?  Are there any limitations on it?  What is the
default number of search levels set by the one-parameter MachinePlayer
constructor?
  Game tree search: Yes.
  Alpha-beta pruning: Yes.
  Limitations: None identified.
  Default searchDepth: 3.


Describe your board evaluation function in some detail.
  Our evaluation function immedietly creates a copy of the board and then places
  the potential move onto this copy. By doing so, we can evaluate the state of
  the board before and after the potential move is made. The maximum amount of 
  points are given for a move that would grant a network for 'this' player while
  also not granting one to the opponent. Conversely, the maximum amount of points
  is deducted for a move that would grant the opponent a network. Points are 
  docked if any more than 2 pieces are placed in either goal. To promote an even
  spread of pieces, points are added for each empty space around a potential move.
  Additionally, points are added for moves that would result in less clustering on
  either the right or the left side of the board. After 4 pieces are already in
  play, and if there are still no pieces in either goal, points are added for 
  moves that would place a chip in one of the goals. The meat of our evaluation
  lies in determining the number of unique connections there are on the board:
  If a move would create more connections for 'this' player, its score is
  increased; decresing the amount of connections the opponent has also 
  adds to the move's score. 


Does your MachinePlayer use any special method of choosing the first few moves?
  Yes. The private method makeFirstMoves() in the MachinePlayer class will place
  the first two moves in two of the four center positions. This method is called
  without having to enter the evaluation methods to save time.

Is there anything else the graders should know to help them read your project?



Describe the classes, modules, and interfaces you designed before and while you
implemented the project.  Your description should include:
  -  A list of the classes your program uses.
  -  A list of each of the "modules" used in or by MachinePlayer, similar to
     the list in the "Teamwork" section of the README (but hopefully more
     detailed).
  -  For each module, list the class(es) the module is implemented in.
  -  For each module, say which of your team members implemented it.
  -  For each module, describe its interface--specifically, the prototype and
     behavior of each method that is available for external callers (outside
     the module) to call.  Don't include methods that are only meant to be
     called from within the module.

     For each method, provide (1) a method prototype and (2) a complete,
     unambiguous description of the behavior of the method/module.  This
     description should also appear before the method in your code's comments.

You will probably need to change some of your design decisions as you go; be
sure to modify this file to reflect these changes before you submit your
project.  Your design of classes and interfaces with be worth about 10% of your
Project 2 grade.


Classes:

  Student-Implemented:
  MachinePlayer
  Board
  Chip
  Direction
  LegalMoves
  MoveIterator
  AI

  Pre-Implemented:
  Player
  Move



Modules:

/**
*Board/Chip Data Structure Module (Ian McLaughlin / Austin Longo):
* -The following describe only the methods related to the data structures used
*  to store the game pieces/states.
* 
*  Chip is a package protected class. The chip constructor takes in an int 
*  parameter called color, which can be either BLACK or WHITE, both final ints,
*  as well as the x and y coords for the Chip's location. It has a boolean 
*  variable called visited that is initially false, but can be set to true by
*  the method flag().
*	
*    Chip(int x, int y, int color)
*       // Constructs a Chip object with position (x, y) and color equal to color.
*    int returnColor() 
*       // Returns the int value corresponding to the color of 'this' Chip. 
*	   void changeColor(int color)
*       // Changes the color of 'this' Chip to color.
*    void flag()
*       // Sets the visited flag of 'this' Chip to true.
*	   void unflag()
*       // Sets the visited flag of 'this' Chip to false.
*    void touch() 
*       // Sets the touched flag of 'this' Chip to true.
*    void untouch()
*       // Sets the touched flag of 'this' Chip to false.
*	   boolean isFlagged()
*       // Returns true if visited is true, false otherwise.
*    int returnColor()
*       // Returns the color of 'this' Chip.
*    int getX() 
*       // Returns the x-coord of 'this' Chip.
*    int getY() 
*       // Returns the y-coord of 'this' Chip.
*    public String toString() 
*       // Returns a String representation of the color of 'this' Chip.
*
*	 The Board class is also package protected. A board object is simply an array
*  of Chips. The Board object has a zero parameter constructer, that allocates 
*  an 8 by 8 size chip array with all Chips having color equal to EMPTY and the
*  corner Chips having color equal to GREY.
*	
*    public Board()
*       // Constructs a new Board as described above.
*    public Board copyBoard()
*       // Creates a copy of 'this' Board.
*    public Chip returnChip(int x, int y) 
*       // Returns the Chip at location (x, y).
*    public int chipColor(int x, int y)
*       // Returns the color of the Chip at location (x, y).
*    public void addChip(Move m, int color)
*       // Changes the color of the Chip given by Move m to color.
*    public void removeChip(int x, int y)
*       // Changes the color of the Chip at (x, y) to EMPTY.
*    public void undoMove(Move m, int color)
*       // Reverts the Move m made by a player with color equal to color.
*    public void setPieces(int col)
*       // Increments the piece counter for the given color col.
*    public void decPieces(int col)
*       // Decrements the piece counter for the given color col.
*    public int getPieces(int col)
*       // Returns the number of pieces in play by the given color col.
*    public Chip[] getCurrChips(int col)
*       // Returns an array of Chip objects containing all the pieces in play by the given color col.
*	   returnChip(in x, int y) returns a chip object at a given point in the chip array.
*	   removeChip(int x, int y) is a method that sets a given point of the chip array as null.
**/

/**
*Legality Checking Module (Austin Longo):
*
*  LegalMoves is a package protected class that contains static methods that can 
*  return all possible moves for a certain player, and also whether a move is
*  valid or not. 
*  class LegalMoves
*  
*    // isLegal() is a package protected static method that takes a move and a 
*    // color as parameters and returns true for a legal move and false for an
*    // illegal move.
*    // @param m is the move we wish to check for legality
*    // @param col is the color of the player making the move
*    // @return true if the move is legal, false otherwise
*    static boolean isLegal(Move m, int col)
*
*    // possibleMoves() is a package protected static method that takes the 
*    // color of the current player and returns a Board object consisting of
*    // null pointers (invalid moves) and Chip objects (valid moves). Calls 
*    // the isLegal() method. 
*    // @param col is the color of the player we wish to consider
*    // @return a Board object of Chips indicating possible moves 
*    static Board possibleMoves(int col)
**/

/**
*Network Checking Module: (Chris Costello)
*
*    // hasNetwork() is a package protected static method that takes a color and
*    // returns true if that color has a network on the board, or false is not.
*    // @param col is the color of the player we wish to consider
*    // @return true to indicate a network was found, or false if not
*    static boolean hasNetwork(int col)
*
*   // explore() is a private method that searches the board for potential moves to hop to.
*    // @param color is the current chip color that might have a network.
*    // @param c is the current chip I'm exploring from
*    // @param length is the amount of hops taken.
*    // @param direction is the direction I came from.
*    // @return true to indicate a network was found, or false if not
*    static boolean explore(int color, Chip c, int length, int direction)
**/

/**
*Evaluation / Search Module:
*
*  AI is a package protected class that contains methods that will perform 
*  game-tree search and implement the mini-max algorithm to search for all
*  possible moves and evaluate them. The search method will then return the 
*  highest rated Move.
*
*    // smartMove() returns the best possible move for a given color. It
*    // implements game-tree search and the mini-max algorithm.
*    // @param col is the color of the player we wish to evaluate for
*    // @param sDepth is the search depth that will be used
*    // @return a Move object
*    static Move smartMove(int col, int sDepth)
**/  


